# -*- coding: utf-8 -*-
"""project1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aZgEEhHXK2fKS92GFS7OOXCsw62BCXhu
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns



file_name = input("Enter the Excel file name (with .xlsx extension): ")
file_path = file_name + ".xlsx"
dataset=pd.read_excel(file_path)

def fill_missing_with_avg_noise_excel(input_path, output_path, exclude_cols=None, noise_range=(-1, 1)):
    if exclude_cols is None:
        exclude_cols = ['date', '_sheet_']

    # Read the Excel file with all sheets
    xls = pd.read_excel(input_path, sheet_name=None)

    filled_sheets = {}
    for sheet_name, df in xls.items():
        df_copy = df.copy()
        cols_to_fill = [col for col in df_copy.columns if col not in exclude_cols]
        for col in cols_to_fill:
            if pd.api.types.is_numeric_dtype(df_copy[col]):
                col_mean = df_copy[col].mean(skipna=True)
                if pd.isna(col_mean):
                    continue  # Skip columns with all NaNs
                mask = df_copy[col].isna()
                noise = np.random.uniform(noise_range[0], noise_range[1], size=mask.sum())
                df_copy.loc[mask, col] = col_mean + noise
        filled_sheets[sheet_name] = df_copy

    # Write back all sheets to the output Excel file
    with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
        for sheet_name, df_filled in filled_sheets.items():
            df_filled.to_excel(writer, sheet_name=sheet_name, index=False)

# Example usage
fill_missing_with_avg_noise_excel(file_path)

# Load data from 'Sheet1' of the Excel file
df = pd.read_excel(file_path, sheet_name='Sheet1')

# Select numeric columns only
numeric_df = df.select_dtypes(include=['number'])

# Calculate correlation matrix (Pearson's correlation by default)
corr = numeric_df.corr()

print(corr)  # Shows correlation coefficients between parameters

# Load your Excel sheet
df = pd.read_excel(file_path, sheet_name='Sheet1')

# Define standard permissible and ideal values for parameters (customize as per relevant guidelines)
standards = {
    'pH': {'ideal': 7.0, 'standard': 8.5, 'weight': 0.11},
    'D__Oxygen': {'ideal': 14.6, 'standard': 6.0, 'weight': 0.17},
    'B_O_D_': {'ideal': 0, 'standard': 5.0, 'weight': 0.11},
    'Nitrate_Nitrogen': {'ideal': 0, 'standard': 10.0, 'weight': 0.10},
    'Turbidity': {'ideal': 0, 'standard': 5.0, 'weight': 0.10},
    # Add other parameters as needed with appropriate weights
}

def quality_rating(value, ideal, standard):
    if value <= ideal:
        return 100
    elif value > standard:
        return 0
    else:
        return round(((standard - value) / (standard - ideal)) * 100, 2)

def calculate_wqi(row):
    weighted_sum = 0
    total_weight = 0
    for param, vals in standards.items():
        if param in row and not pd.isna(row[param]):
            qr = quality_rating(row[param], vals['ideal'], vals['standard'])
            weighted_sum += qr * vals['weight']
            total_weight += vals['weight']
    if total_weight > 0:
        return weighted_sum / total_weight
    else:
        return np.nan

def classify_wqi(wqi):
    if pd.isna(wqi):
        return 'Unknown'
    elif wqi >= 90:
        return 'Excellent'
    elif wqi >= 70:
        return 'Very Good'
    elif wqi >= 50:
        return 'Good'
    elif wqi >= 25:
        return 'Poor'
    else:
        return 'Very Poor / Unsuitable'

# Calculate WQI for each row (sampled water point)
df['WQI'] = df.apply(calculate_wqi, axis=1)
df['Water_Quality_Class'] = df['WQI'].apply(classify_wqi)

print(df[['WQI', 'Water_Quality_Class']])

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report


# Load dataset from given Excel file and sheet
#file_path = '/content/Final_Copy_Of_Yatch_Club.xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet1')

# WHO standards for parameters (simplified for demo)
standards = {
    'pH': {'ideal': 7.0, 'standard': 8.5, 'weight': 0.11},
    'D__Oxygen': {'ideal': 14.6, 'standard': 6.0, 'weight': 0.17},
    'B_O_D_': {'ideal': 0, 'standard': 5.0, 'weight': 0.11},
    'Nitrate_Nitrogen': {'ideal': 0, 'standard': 50.0, 'weight': 0.10},
    'Turbidity': {'ideal': 0, 'standard': 5.0, 'weight': 0.10},
}

# Function to calculate quality rating for each parameter
def quality_rating(value, ideal, standard):
    if value <= ideal:
        return 100
    elif value > standard:
        return 0
    else:
        return ((standard - value) / (standard - ideal)) * 100

# Calculate WQI for each row based on weighted quality ratings
def calculate_wqi(row):
    weighted_sum = 0
    total_weight = 0
    for param, vals in standards.items():
        if param in row and pd.notna(row[param]):
            qr = quality_rating(row[param], vals['ideal'], vals['standard'])
            weighted_sum += qr * vals['weight']
            total_weight += vals['weight']
    if total_weight > 0:
        return weighted_sum / total_weight
    else:
        return None

# Classify WQI into water quality categories
def classify_wqi(wqi):
    if wqi is None:
        return None
    elif wqi >= 90:
        return 'Excellent'
    elif wqi >= 70:
        return 'Very Good'
    elif wqi >= 50:
        return 'Good'
    elif wqi >= 25:
        return 'Poor'
    else:
        return 'Very Poor / Unsuitable'

# Calculate WQI and classify water quality
df['WQI'] = df.apply(calculate_wqi, axis=1)
df['Water_Quality_Class'] = df['WQI'].apply(classify_wqi)

# Drop rows with missing target or features
features = ['pH', 'D_Oxygen', 'B_O_D_', 'Nitrate_Nitrogen', 'Turbidity']
model_df = df.dropna(subset=features + ['Water_Quality_Class'])

X = model_df[features]
y = model_df['Water_Quality_Class']

# Encode target labels
le = LabelEncoder()
y_encoded = le.fit_transform(y)

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

# Scale features for Logistic Regression
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Train Logistic Regression
lr = LogisticRegression(max_iter=200)
lr.fit(X_train_scaled, y_train)

# Train Random Forest
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Train Decision Tree
dt = DecisionTreeClassifier(random_state=42)
dt.fit(X_train, y_train)

# Evaluate models
lr_pred = lr.predict(X_test_scaled)
rf_pred = rf.predict(X_test)
dt_pred = dt.predict(X_test)

print("Logistic Regression Classification Report:")
print(classification_report(y_test, lr_pred, target_names=le.classes_, zero_division=1))

print("Random Forest Classification Report:")
print(classification_report(y_test, rf_pred, target_names=le.classes_, zero_division=1))

print("Decision Tree Classification Report:")
print(classification_report(y_test, dt_pred, target_names=le.classes_, zero_division=1))


# Function for user to input data and predict water quality class using all models
def predict_water_quality(user_input_dict):
    input_df = pd.DataFrame([user_input_dict])
    input_scaled = scaler.transform(input_df)

    lr_pred = le.inverse_transform(lr.predict(input_scaled))[0]
    rf_pred = le.inverse_transform(rf.predict(input_df))[0]
    dt_pred = le.inverse_transform(dt.predict(input_df))[0]

    return {
        'Logistic Regression': lr_pred,
        'Random Forest': rf_pred,
        'Decision Tree': dt_pred
    }

# Example user input
example_input = {
    'pH': 7.2,
    'D__Oxygen': 7.5,
    'B_O_D_': 2.0,
    'Nitrate_Nitrogen': 15.0,
    'Turbidity': 3.0
}

predictions = predict_water_quality(example_input)
print("Prediction on example input:")
print(predictions)

# Load dataset
file_path = 'Copy of kamla_editv.1(1).xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet1')

# Assuming WQI column is already calculated in the dataframe
# If not, calculate it before running this code (use your existing calculate_wqi function)

# List of all relevant parameters (columns) to consider for suggestions:
param_columns = [
    'Alkalinity', 'Ammonium_Nitrogen', 'B_O_D_', 'C_O_D_', 'Calcium_Hardness', 'Chloride',
    'Conductivity', 'D__Oxygen', 'Magnesium', 'Magnesium_Hardness', 'Nitrate_Nitrogen',
    'Nitrite__Nitrogen', 'Phosphate_(PO4)', 'Potassium', 'S__Solids', 'Sodium',
    'Sulphate_(SO4)', 'T__D__S_', 'Temperature', 'Turbidity', 'pH'
]

# Classify water quality class based on WQI value
def classify_wqi_simple(wqi):
    if wqi is None:
        return None
    elif wqi >= 90:
        return 'Excellent'
    elif wqi >= 70:
        return 'Very Good'
    elif wqi >= 50:
        return 'Good'
    elif wqi >= 25:
        return 'Poor'
    else:
        return 'Very Poor / Unsuitable'

# Suggest parameter ranges based on nearby WQI values within delta
def suggest_param_ranges(wqi_input, df, delta=2):
    matched_rows = df[(df['WQI'] >= wqi_input - delta) & (df['WQI'] <= wqi_input + delta)]
    if matched_rows.empty:
        return None
    param_ranges = {}
    for param in param_columns:
        if param in matched_rows:
            param_ranges[param] = {
                'min': matched_rows[param].min(),
                'max': matched_rows[param].max(),
                'mean': matched_rows[param].mean()
            }
    return param_ranges

# Main prediction function: input WQI, output class plus parameter ranges
def predict_from_wqi(wqi_input, df):
    water_quality_class = classify_wqi_simple(wqi_input)
    param_suggestions = suggest_param_ranges(wqi_input, df)
    return {
        'Input_WQI': wqi_input,
        'Water_Quality_Class': water_quality_class,
        'Suggested_Parameter_Ranges': param_suggestions
    }

# Example usage:
user_wqi = 72  # For example, user inputs WQI = 72
result = predict_from_wqi(user_wqi, df)

print(f"Input WQI: {result['Input_WQI']}")
print(f"Predicted Water Quality Class: {result['Water_Quality_Class']}")
print("Suggested parameter ranges for this WQI:")
if result['Suggested_Parameter_Ranges'] is not None:
    for param, stats in result['Suggested_Parameter_Ranges'].items():
        print(f"  {param}: min={stats['min']:.2f}, max={stats['max']:.2f}, mean={stats['mean']:.2f}")
else:
    print("  No data available for this WQI range.")

"""THe code is predicting the water quality index for the water bodies and providing various parameters to the user so that they can use the water body based on the predicted parameters...."""

# Load dataset
file_path = '/content/Final_Copy_Of_Yatch_Club.xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet1')

# Your WHO standards for parameters used in WQI calculation
standards = {
    'pH': {'ideal': 7.0, 'standard': 8.5, 'weight': 0.11},
    'D__Oxygen': {'ideal': 14.6, 'standard': 6.0, 'weight': 0.17},
    'B_O_D_': {'ideal': 0, 'standard': 5.0, 'weight': 0.11},
    'Nitrate_Nitrogen': {'ideal': 0, 'standard': 50.0, 'weight': 0.10},
    'Turbidity': {'ideal': 0, 'standard': 5.0, 'weight': 0.10},
}

# List of all parameters in your dataset
param_columns = [
    'Alkalinity', 'Ammonium_Nitrogen', 'B_O_D_', 'C_O_D_', 'Calcium_Hardness', 'Chloride',
    'Conductivity', 'D__Oxygen', 'Magnesium', 'Magnesium_Hardness', 'Nitrate_Nitrogen',
    'Nitrite__Nitrogen', 'Phosphate_(PO4)', 'Potassium', 'S__Solids', 'Sodium',
    'Sulphate_(SO4)', 'T__D__S_', 'Temperature', 'Turbidity', 'pH'
]

# Function to calculate quality rating for each parameter used in WQI
def quality_rating(value, ideal, standard):
    if value <= ideal:
        return 100
    elif value > standard:
        return 0
    else:
        return ((standard - value) / (standard - ideal)) * 100

# Calculate WQI for each row based on weighted quality ratings
def calculate_wqi(row):
    weighted_sum = 0
    total_weight = 0
    for param, vals in standards.items():
        if param in row and pd.notna(row[param]):
            qr = quality_rating(row[param], vals['ideal'], vals['standard'])
            weighted_sum += qr * vals['weight']
            total_weight += vals['weight']
    if total_weight > 0:
        return weighted_sum / total_weight
    else:
        return np.nan

# Add WQI column to dataframe
df['WQI'] = df.apply(calculate_wqi, axis=1)

# Function to classify water quality class from WQI
def classify_wqi_simple(wqi):
    if pd.isna(wqi):
        return None
    elif wqi >= 90:
        return 'Excellent'
    elif wqi >= 70:
        return 'Very Good'
    elif wqi >= 50:
        return 'Good'
    elif wqi >= 25:
        return 'Poor'
    else:
        return 'Very Poor / Unsuitable'

df['Water_Quality_Class'] = df['WQI'].apply(classify_wqi_simple)

# Function to suggest parameter ranges by finding all rows in dataset with WQI within Â± delta of user input WQI
def suggest_param_ranges(wqi_input, df, delta=2):
    matched_rows = df[(df['WQI'] >= wqi_input - delta) & (df['WQI'] <= wqi_input + delta)]
    if matched_rows.empty:
        return None
    param_ranges = {}
    for param in param_columns:
        if param in matched_rows:
            param_ranges[param] = {
                'min': matched_rows[param].min(),
                'max': matched_rows[param].max(),
                'mean': matched_rows[param].mean()
            }
    return param_ranges

# Main function for user input WQI to predict quality class and parameter ranges
def predict_parameters_from_wqi(wqi_input, df):
    water_quality_class = classify_wqi_simple(wqi_input)
    param_suggestions = suggest_param_ranges(wqi_input, df)
    return {
        'Input_WQI': wqi_input,
        'Water_Quality_Class': water_quality_class,
        'Suggested_Parameter_Ranges': param_suggestions
    }

# Example usage
input_wqi = int(input("Enter the WQI for the water body that you want to test: "))  # User inputs this WQI
result = predict_parameters_from_wqi(input_wqi, df)

print(f"Input WQI: {result['Input_WQI']}")
print(f"Predicted Water Quality Class: {result['Water_Quality_Class']}")
print("Suggested parameter ranges for given WQI:")
if result['Suggested_Parameter_Ranges'] is not None:
    for param, stats in result['Suggested_Parameter_Ranges'].items():
        print(f"{param}: min={stats['min']:.3f}, max={stats['max']:.3f}, mean={stats['mean']:.3f}")
else:
    print("No data available for this WQI range.")

"""The code will check which algorithm will run best for the above mentioned data"""

from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, accuracy_score

# Load dataset
file_path = '/content/Final_Copy_Of_Yatch_Club.xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet1')

# Print column names to verify
print(df.columns)

# Parameters, their ideal and standard values, and weights for WQI
standards = {
    'pH': {'ideal': 7.0, 'standard': 8.5, 'weight': 0.11},
    'D___Oxygen': {'ideal': 14.6, 'standard': 6.0, 'weight': 0.17},
    'B_O_D_': {'ideal': 0, 'standard': 5.0, 'weight': 0.11},
    'Nitrate_Nitrogen': {'ideal': 0, 'standard': 50.0, 'weight': 0.10},
    'Turbidity': {'ideal': 0, 'standard': 5.0, 'weight': 0.10}
}

# Function to calculate quality rating per parameter
def quality_rating(value, ideal, standard):
    if pd.isna(value):
        return np.nan
    if value <= ideal:
        return 100
    elif value >= standard:
        return 0
    else:
        return ((standard - value) / (standard - ideal)) * 100

# Calculate WQI score for each row
def calculate_wqi(row):
    numerator = 0
    denominator = 0
    for param, vals in standards.items():
        q = quality_rating(row[param], vals['ideal'], vals['standard'])
        if not pd.isna(q):
            numerator += q * vals['weight']
            denominator += vals['weight']
    return numerator / denominator if denominator != 0 else np.nan

df['WQI'] = df.apply(calculate_wqi, axis=1)

# Classify WQI into water quality classes
def classify_wqi(wqi):
    if pd.isna(wqi):
        return np.nan
    elif wqi >= 90:
        return 4  # Excellent
    elif wqi >= 70:
        return 3  # Very Good
    elif wqi >= 50:
        return 2  # Good
    elif wqi >= 25:
        return 1  # Poor
    else:
        return 0  # Very Poor

df['WQI_class'] = df['WQI'].apply(classify_wqi)

# Features and target for ML models
feature_cols = [
    'Alkalinity', 'Ammonium_Nitrogen', 'B_O_D_', 'C_O_D_', 'Calcium_Hardness', 'Chloride',
    'Conductivity', 'D___Oxygen', 'Magnesium_Hardness', 'Nitrate_Nitrogen',
    'Nitrite_Nitrogen', 'Phosphate_(PO4)', 'Potassium', 'S__Solids', 'Sodium',
    'Sulphate_(SO4)', 'T_D_S', 'Temperature', 'Turbidity', 'pH'
]

# Filter rows without missing values in features or target
model_df = df.dropna(subset=feature_cols + ['WQI_class'])

X = model_df[feature_cols]
y = model_df['WQI_class'].astype(int)

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize models
clf_dt = DecisionTreeClassifier(random_state=42)
clf_rf = RandomForestClassifier(random_state=42)
clf_lr = LogisticRegression(max_iter=1000, random_state=42)

# Train the models
clf_dt.fit(X_train, y_train)
clf_rf.fit(X_train, y_train)
clf_lr.fit(X_train, y_train)

# Predictions
pred_dt = clf_dt.predict(X_test)
pred_rf = clf_rf.predict(X_test)
pred_lr = clf_lr.predict(X_test)

# Evaluation
report_dt = classification_report(y_test, pred_dt, zero_division=1)
report_rf = classification_report(y_test, pred_rf, zero_division=1)
report_lr = classification_report(y_test, pred_lr, zero_division=1)

accuracy_dt = accuracy_score(y_test, pred_dt)
accuracy_rf = accuracy_score(y_test, pred_rf)
accuracy_lr = accuracy_score(y_test, pred_lr)

print(f"Decision Tree Accuracy: {accuracy_dt:.2f}\n{report_dt}\n")
print(f"Random Forest Accuracy: {accuracy_rf:.2f}\n{report_rf}\n")
print(f"Logistic Regression Accuracy: {accuracy_lr:.2f}\n{report_lr}\n")

